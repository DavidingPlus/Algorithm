// 题目测试链接；https://www.acwing.com/problem/content/2
// 动态规划背包问题归纳博客：https://blog.csdn.net/qq_47540091/article/details/125505851?spm=1001.2014.3001.5501

#include <iostream>
#include <vector>

const int N = 1e3 + 10;

int main()
{
    int n, v;
    std::cin >> n >> v;
    int data[n][2] = {0};
    for (int i = 0; i < n; ++i)
    {
        std::cin >> data[i][0] >> data[i][1];
    }

    // 定义 dp 数组，dp[i][j] 代表取 0 到 i 的物品装入容量为 j 的背包的最大价值
    // 从下面的分析知道，每一行的结果之和上一行有关，因此完全可以只用一个一维数组存储，优化空间复杂度
    // 但是由于 C/C++ 中没办法直接对原生数组指针进行赋值（指针常量），因此想了一个办法，还是开二维，只不过 i 方向只开 2，也是常量级别了，后面的 i 求 2 的余数即可
    // 注意一件事情，就是在使用原生数组的时候，最好不要使用含变量的数组，对于下面大小确定的数组，编译器会在编译期就分配空间，但是对于含变量的数组，例如， dp [n] ，目前的 c++ 编译器虽然支持，但是不推荐使用，因为一旦操作不当，就可能出现各种奇奇怪怪的问题，处理这种可以使用动态开辟或者 std::vector<>
    // 其次，很重要的一点就是，千万不要使用类似 dp[2][1 + v] 这种，第一维告诉编译器是常量，编译器在编译期的时候看到第二维是变量，傻眼了，所以会出现不可预期的结果
    // 至于为什么我会写 dp[n][1 + v] 呢？别问，问就是 python 害的
    // TODO 有空可以调研一下， dp[n][1 + v] 和 dp[3][1 + v] 结果是对的，但是 dp[2][1 + v] 不对，这里面肯定扯到更多的学问
    int dp[2][N] = {0}; // 这里其实开 N 浪费了，但是我不想开 vector，因此这个尚可接受

    // 更新 dp， 当我每次加入一个新物品的时候，整个集合的任意选取可以分为两类，一类是含新物品，一类是不含，不含的最大值当然 dp[i - 1][j] ，含的情况下既然已经包含了新物品，所以其他物品能放入背包的容量为 j - v(i)，因此最大值显而易见就是 w(i) + dp[i - 1][j - v(i)]，取二者最大值即可，这就是状态转移方程
    // 填充第一行
    for (int j = 0; j < 1 + v; ++j)
    {
        dp[0][j] = j >= data[0][0] ? data[0][1] : 0;
    }
    // 开始推导
    for (int i = 1; i < n; ++i)
    {
        for (int j = 1; j < 1 + v; ++j)
        {
            // 有可能新加入的物品根本放不下，这种情况直接返回上一层的即可
            if (j < data[i][0])
            {
                dp[i & 1][j] = dp[(i - 1) & 1][j];
            }
            else
            {
                dp[i & 1][j] = std::max(dp[(i - 1) & 1][j], data[i][1] + dp[(i - 1) & 1][j - data[i][0]]);
            }
        }
    }
    std::cout << dp[(n - 1) & 1][v] << '\n';

    return 0;
}
